#' Parse the KEGG module database
#'
#' Read the KEGG module database text file and format it into a reference table.
#' 
#' @details 
#' The columns are automatically generated by the \code{parseKEGG_file} function into variables, 
#' which are further formatted specifically for the KEGG module database.
#' 
#' The text file used is "\code{KEGG_path}/module/module". 
#' 
#' It decompresses "\code{KEGG_path}/module/module.gz" if needed.
#'
#' @param KEGG_path - string pointing to the location of the KEGG database parent folder
#'
#' @param outDir        - string pointing to the output folder. Default ("output/"). \code{NULL} overwrites existing files.
#'
#' @param verbose       - logical. Should progress be printed to the screen? Default (\code{TRUE})
#'
#' @param shortName_file_path - file path to table containing Module IDs (column 1), Short name (column 2). Default (\code{""})
#'
#' @param ...       - other arguments for \code{parseKEGG_file()}
#'
#' @details
#' DEFINITION: Logical Expression (adapted from \link{http://www.genome.jp/kegg/module.html})
#'
#' The MODULEs (identified by an M number; e.g. "M00001") are defined by a logical expression (DEFINITION) of KEGG orthologs
#' (KO numbers, KOs; e.g. "K00001") and sometimes other M numbers, facilitating the automatic evaluation of whether a
#' module is complete in a given genome.
#'
#' A MODULE is made up of BLOCKS (SPACE delimited). Each block is defined by a logical expression
#' to determine which KOs are needed in the definition.
#' All BLOCKS must be present to be able to state that a MODULE is COMPLETE.
#'
#' The KEGG module DEFINITION has been formatted to simplify its use, but the logical expression is conserved.
#' Where space or a plus sign represent AND operations in the KEGG definition,
#' we have replaced all instances with \code{'&'}. Similarly, we have replaced all comas (used within KEGG to represent an OR operation)
#' with pipes (\code{'|'}).
#'
#' We have also translated the K number based DEFINITION to an enzyme based DEFINITION using the ORTHOLOGY information.
#' K numbers can be mapped to enzymes using the Enzyme Classification (EC) numbers (redundancy expected).
#' Note that not all K numbers have an association to an EC number.
#' In these instances, the K numbers have been left in the MODULE DEFINITION.
#' When evaluating whether a MODULE is complete using EC numbers, the user must decide whether to assume that those genes
#' are present or not (deafult). See \link{query_genomes_to_modules}
#'
#' Optional items in the complex or definition (denoted by a minus sign) have been removed from the main definition
#' and listed as a separate column under \code{'OPTIONAL_' (EC or K numbers)}.
#'
#' \code{shortName_file_path} can be used to provide the path to a file listing:\preformatted{
#'  Column named 'ID'         - KEGG module ID (M numbers),
#'  Column named 'NAME'       - KEGG module NAME,
#'  Column names 'NAME_SHORT' - manually abbreviated names for plotting purposes.
#' }
#' \code{NAME_SHORT} abbreviations: 2-CRS, two-component regulatory system; PS, photosystem/photosynthesis; pwy, pathway; TS, transport system; R, resistance;
#'
#' @return Generates module_reference_table (.txt & .rda; saved to \code{'outDir'}) and returns
#' a data frame with as many rows as entries and the following columns (or variables):
#' \preformatted{
#' 	      (1) ID             - KEGG module identifier (M number; e.g. "M00001");
#' 	      (2) NAME           - KEGG module name;
#' 	      (3) NAME_SHORT     - abbreviated module name (for visualization purposes);
#' 	      (4) DEFINITION_KOs - module definition as a logical expression (see Details) 
#' 	                            in terms of KEGG Orthologs;
#' 	      (5) DEFINITION_ECs - module definition as a logical expression (see Details) 
#' 	                            in terms of EC numbers;
#' 	      (6) OPTIONAL_KOs   - optional K numbers listed;
#' 	      (7) OPTIONAL_ECs   - optional EC numbers listed;
#' 	      (8) ORTHOLOGY      - relationship between K and EC numbers;
#' 	 (9 - 11) CLASS_I - III  - hierarchical module classes;
#' 	     (12) PATHWAY        - pathway(s)  in which the module is involved (map### and 
#' 	                            name);
#' 	     (13) REACTION       - reaction(s) in which the module is involved (R##### and 
#' 	                            their corresponding compound IDs);
#' 	     (14) COMPOUND       - compund(s)  in which the module is involved (C#####);
#' 	     (15) DBLINKS;         (16) RMODULE;         (17) REFERENCE;         
#' 	     (18) COMMENT;         (19) BRITE;
#'
#'  *In all instances, multiple entries in a given column are separated by '[;]'.
#' }
#'
#' @export
#'
#' @seealso \link{parseKEGG_file}, \link{misc_module_definition_check},
#' 
#' @seealso \link{misc_module_definition_optional},' \link{misc_module_definition_block_EC}

################################ STEPS ########################################################
# 1.    MANAGE INPUT  - format paths and check/make outDir
# 2.    PROCESS FILE  - path structure to file self-contained as per KEGG data structure
# 2.1     Check if file is compressed
#           Uses - 'KEGG_path/module/module'
# 2.2     Format file to table
#           Uses - parseKEGG_file()
# 3.    FORMAT MODULE TABLE
# 3.1     ENTRY (column 1) changed to ID and contains only module number (M\\d{5})
# 3.2     Split CLASS into 3 classes
# 3.3     Format ORTHOLOGY
# 3.4     Format DEFINITION_KOs (K number-based)
# 3.4.1     Determine BLOCKS and do substitutions (particularly '+' -> '&', ',' -> '|')
#             Uses - module_definition_check()
# 3.4.2     Find optional
#             Uses - module_definition_optional()
# 3.4.3     Translate to EC-base definition (DEFINITION_ECs)
#             Uses - module_definition_block_EC()
# 3.4.4     Add NAME_SHORT - manually defined short name for plotting, etc
#             Uses - shortName_file_path . Deafult - 'data/module_shortName_mapping.txt'
# 4.    WRITE TABLE  (.txt, .rda)
##############################################################################################

parseKEGG_module <- function(KEGG_path, outDir = "output", verbose = T,shortName_file_path="",...){

  ####  MANAGE INPUT ----
  # CHECKS
  stopifnot(is.character(KEGG_path),length(KEGG_path)==1,dir.exists(KEGG_path))
  stopifnot((is.character(outDir)&&length(outDir)==1)||is.null(outDir))
  stopifnot(is.logical(verbose))

  # FORMAT PATHS
  KEGG_path <- gsub("/$","",KEGG_path) # end file path WITHOUT ending "/"
  if(!is.null(outDir)) outDir    <- gsub("/$","",outDir)

  # OUTPUT FOLDER
  if(!is.null(outDir)) if(!dir.exists(outDir)) dir.create(outDir)

  ####  PROCESS FILE ----
  if(verbose) cat("\tmodule processing...",fill = T)
  start <- Sys.time()

  #####   UNTAR FILE ----
    if(!file.exists(paste(KEGG_path,"/module/module",sep=""))) {
      if(verbose) cat("\n\t\tDecompressing module file...",fill = T)
      R.utils::gunzip(paste(KEGG_path,"/module/module.gz",sep=""),destname = paste(KEGG_path,"/module/module",sep=""),remove = F)
    }

  ####  PROCESS FILE ----
  module_file       <- paste(KEGG_path,"/module/module",sep="")

  # PROCESS FILE INTO DATA FRAME
  module_reference_table  <- parseKEGG_file(module_file,verbose = verbose,...)

  ####  FORMAT TABLE                    ----
  module_reference_table$ENTRY      <- gsubfn::strapplyc(pattern = "M\\d{5}",module_reference_table$ENTRY,simplify = T)
  names(module_reference_table)[1]  <- "ID"

  #####   SPLIT CLASSES              ----
  CLASSES <- data.frame(CLASS_I   = character(nrow(module_reference_table)),
                        CLASS_II  = character(nrow(module_reference_table)),
                        CLASS_III = character(nrow(module_reference_table)),
                        stringsAsFactors = F)

  for(j in 1:nrow(module_reference_table)) CLASSES[j,] <- gsub("^ ","",strsplit(module_reference_table$CLASS[j],split = ";")[[1]][1:3])

  class_col_index <- which(names(module_reference_table)=="CLASS")
  if(class_col_index!=ncol(module_reference_table))
    module_reference_table <- cbind(module_reference_table[,1:(class_col_index-1)],CLASSES,module_reference_table[,(class_col_index+1):ncol(module_reference_table)])

  if(class_col_index==ncol(module_reference_table))
    module_reference_table <- cbind(module_reference_table[,1:(class_col_index-1)],CLASSES) # unlikely
  #####   ORTHOLOGY and EC numbers    ----
    # Relate KEGG ortholog (KO) with EC numbers
    module_reference_table$ORTHOLOGY  <- gsub("]","",module_reference_table$ORTHOLOGY,fixed = T)
    module_reference_table$ORTHOLOGY  <- gsub("[","",module_reference_table$ORTHOLOGY,fixed = T)
    module_reference_table$ORTHOLOGY  <- gsub("; ","- ",module_reference_table$ORTHOLOGY,fixed = T)

  #####   DEFINITION                                              ----
  ####      PROCESS DEFINITION, FIND OPTIONAL KOs AND MAP TO ECs  ----
    # MANAGE DEFINITIONS ACROSS MULTIPLE LINES
    module_reference_table$DEFINITION <- gsub("[;]"," ",module_reference_table$DEFINITION)

    # STORE VARIABLES
    DEFINITION_KOs  <- character(nrow(module_reference_table))
    DEFINITION_ECs  <- character(nrow(module_reference_table))
    OPTIONAL_KOs    <- character(nrow(module_reference_table))
    OPTIONAL_ECs    <- character(nrow(module_reference_table))
    for(D in 1:nrow(module_reference_table)){
      DEFINITION_KOs[D] <- misc_module_definition_check(module_reference_table$DEFINITION[D])
      ORTHOLOGS         <- strsplit(module_reference_table$ORTHOLOGY[D],split = ";")[[1]] # temp
      ## EXTRACT THE DEFINITION BLOCKS
      blocks    <- strsplit(DEFINITION_KOs[D],split = " ")[[1]]
      blocks_EC <- character(length(blocks))

      # FIND OPTIONAL KOs and ECs and TRANSLATE DEFINITION TO ECs ----
      optional_KOs_temp <- NULL
      optional_ECs_temp <- NULL
      for(B in 1:length(blocks)){

        ## FIND OPTIONAL KOs and ECs and exclude them from both DEFINITIONS
        if(length(grep("-",blocks[B]))>0){
          output <- misc_module_definition_optional(blocks[B],ORTHOLOGS)
            # output: block w/o optional and optional list
          blocks[B]     <- output$thisBlock
          optional_KOs_temp  <- c(optional_KOs_temp, output$thisOptional_KOs)
          optional_ECs_temp  <- c(optional_ECs_temp, output$thisOptional_ECs)
        } # end if optionals are present

        ##  TRANSLATE KO BLOCK TO EC BLOCK
        blocks_EC[B] <- misc_module_definition_block_EC(blocks[B],ORTHOLOGS)
      } # end blocks loop

      # RECONSTRUCT DEFINITION_KOs (after removing optional KOs, etc)
      DEFINITION_KOs[D] <- paste(blocks,collapse = " ")

      # HAVE A SECOND DEFINITION STATEMENT BASED ON EC NUMBERS
      DEFINITION_ECs[D]  <- paste(blocks_EC,collapse = " ")

      # MANAGE OPTIONALS
      OPTIONAL_KOs[D] <- ifelse(is.null(optional_KOs_temp),"NA",paste(optional_KOs_temp,collapse = ";"))
      OPTIONAL_ECs[D] <- ifelse(is.null(optional_ECs_temp),"NA",paste(optional_ECs_temp,collapse = ";"))
    }

    # ADD NEW COLUMNS
    DEFINITIONS <- cbind(DEFINITION_KOs,DEFINITION_ECs,OPTIONAL_KOs,OPTIONAL_ECs)
    def_col_index <- which(names(module_reference_table)=="DEFINITION")
    if(def_col_index!=ncol(module_reference_table))
      module_reference_table <- cbind(module_reference_table[,1:(def_col_index-1)],DEFINITIONS,module_reference_table[,(def_col_index+1):ncol(module_reference_table)])

    if(def_col_index==ncol(module_reference_table))
      module_reference_table <- cbind(module_reference_table[,1:(def_col_index-1)],DEFINITIONS) # unlikely

    # NEW VARIABLE DEFAULT TO 'FACTOR'
    module_reference_table$DEFINITION_KOs <- as.character(module_reference_table$DEFINITION_KOs)
    module_reference_table$DEFINITION_ECs <- as.character(module_reference_table$DEFINITION_ECs)
    module_reference_table$OPTIONAL_KOs   <- as.character(module_reference_table$OPTIONAL_KOs)
    module_reference_table$OPTIONAL_ECs   <- as.character(module_reference_table$OPTIONAL_ECs)

  #####   ADD SHORT NAME FOR MODULES ----
    NAME_SHORT              <- module_reference_table$NAME
    name_col_index          <- which(names(module_reference_table)=="NAME")
    module_reference_table  <- cbind(module_reference_table[,1:(name_col_index)],NAME_SHORT,module_reference_table[,(name_col_index+1):ncol(module_reference_table)])
    # CHANGE FORM FACTOR TO CHARACTER TYPE
    module_reference_table$NAME_SHORT <- as.character(module_reference_table$NAME_SHORT)

    if(shortName_file_path!=""&&is.character(shortName_file_path)&&length(shortName_file_path)==1&&file.exists(shortName_file_path)){
      module_shortName_mapping    <- read.delim(file = shortName_file_path,stringsAsFactors = F)
    } else{
      data("data_module_shortName_mapping")
      module_shortName_mapping    <- data_module_shortName_mapping
    }

    mod_ref_index_match                                     <- which(!is.na(match(module_reference_table$ID,module_shortName_mapping$module_ID)))
    mod_ref_shortName_index_match                           <- which(!is.na(match(module_shortName_mapping$module_ID,module_reference_table$ID)))
    module_reference_table$NAME_SHORT[mod_ref_index_match]  <- module_shortName_mapping$NAME_SHORT[mod_ref_shortName_index_match]

    # CHECK THAT ALL MODULE ENTRIES READ HAVE A
    short_name_na_index     <- which(is.na(match(module_reference_table$ID,module_shortName_mapping$module_ID)))
    if(length(short_name_na_index)>0){
      missing <- module_reference_table$ID[short_name_na_index]
      warning(paste(length(short_name_na_index),"module entries without a reference short name:",paste(missing,collapse = "\t")))
    }

  ####  WRITE TABLE  (.txt, .rda) ----
  module_reference_table_file <- paste(outDir,"/module_reference_table.txt",sep="")
  if(!is.null(outDir)){
    write.table(module_reference_table,file = module_reference_table_file,sep = "\t",row.names = F,quote = F)
    save(module_reference_table,file = gsub(".txt",".rda",module_reference_table_file))
  }
  if(verbose) cat("\t Completed in",format(difftime(Sys.time(),start,units = "mins"),digits = 4),"\n",fill = T)

  ### RETURN ---
  return(module_reference_table)
}
